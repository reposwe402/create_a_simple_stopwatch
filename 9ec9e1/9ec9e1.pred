{"model_name_or_path": "create_a_simple_stopwatch", "instance_id": "9ec9e1", "model_patch": "diff --git a/stopwatch.py b/stopwatch.py\nindex 47dd4b1..852bce1 100644\n--- a/stopwatch.py\n+++ b/stopwatch.py\n@@ -1,81 +1,4 @@\n-import tkinter as Tkinter\n-from datetime import datetime\n-counter = 0\n-running = False\n+from ui import setup_ui\n \n-\n-def counter_label(label):\n-    def count():\n-        if running:\n-            global counter\n-\t\t\t# To manage the intial delay. \n-            if counter == 0:\n-                display = 'Ready!'\n-            else:\n-                tt = datetime.utcfromtimestamp(counter)\n-                string = tt.strftime('%H:%M:%S')\n-                display = string\n-\t\n-            label['text'] = display\n-\t\n-\t\t\t# label.after(arg1, arg2) delays by \n-\t\t\t# first argument given in milliseconds \n-\t\t\t# and then calls the function given as second argument. \n-\t\t\t# Generally like here we need to call the \n-\t\t\t# function in which it is present repeatedly. \n-\t\t\t# Delays by 1000ms=1 seconds and call count again. \n-            label.after(1000, count)\n-            counter += 1\n-\t\n-\t# Triggering the start of the counter. \n-    count()\n-\t\n-\n-# start function of the stopwatch \n-def Start(label):\n-    global running\n-    running = True\n-    counter_label(label)\n-    start['state'] = 'disabled'\n-    stop['state'] = 'normal'\n-    reset['state'] = 'normal'\n-\t\n-\n-# Stop function of the stopwatch \n-def Stop():\n-    global running\n-    start['state'] = 'normal'\n-    stop['state'] = 'disabled'\n-    reset['state'] = 'normal'\n-    running = False\n-\t\n-\n-# Reset function of the stopwatch \n-def Reset(label):\n-\tglobal counter\n-\tcounter = 0\n-\t# If reset is pressed after pressing stop. \n-\tif not running:\n-\t\treset['state'] = 'disabled'\n-\t\tlabel['text'] = '00:00:00'\n-\t# If reset is pressed while the stopwatch is running. \n-\telse:\n-\t\tlabel['text'] = '00:00:00'\n-\n-\n-root = Tkinter.Tk()\n-root.title(\"Stopwatch\")\n-\n-# Fixing the window size.\n-root.minsize(width=250, height=70)\n-label = Tkinter.Label(root, text='Ready!', fg='black', font='Verdana 30 bold')\n-label.pack()\n-f = Tkinter.Frame(root)\n-start = Tkinter.Button(f, text='Start', width=6, command=lambda: Start(label))\n-stop = Tkinter.Button(f, text='Stop', width=6, state='disabled', command=Stop)\n-reset = Tkinter.Button(f, text='Reset', width=6, state='disabled', command=lambda: Reset(label))\n-f.pack(anchor='center', pady=5)\n-start.pack(side='left')\n-stop.pack(side='left')\n-reset.pack(side='left')\n-root.mainloop()\n+if __name__ == \"__main__\":\n+    label, start, stop, reset = setup_ui()\ndiff --git a/stopwatch_logic.py b/stopwatch_logic.py\nnew file mode 100644\nindex 0000000..20cfabe\n--- /dev/null\n+++ b/stopwatch_logic.py\n@@ -0,0 +1,44 @@\n+counter = 0\n+running = False\n+\n+def counter_label(label):\n+    def count():\n+        if running:\n+            global counter\n+            if counter == 0:\n+                display = 'Ready!'\n+            else:\n+                tt = datetime.utcfromtimestamp(counter)\n+                string = tt.strftime('%H:%M:%S')\n+                display = string\n+            label['text'] = display\n+            label.after(1000, count)\n+            counter += 1\n+    count()\n+\n+\n+def Start(label):\n+    global running\n+    running = True\n+    counter_label(label)\n+    start['state'] = 'disabled'\n+    stop['state'] = 'normal'\n+    reset['state'] = 'normal'\n+\n+\n+def Stop():\n+    global running\n+    start['state'] = 'normal'\n+    stop['state'] = 'disabled'\n+    reset['state'] = 'normal'\n+    running = False\n+\n+\n+def Reset(label):\n+    global counter\n+    counter = 0\n+    if not running:\n+        reset['state'] = 'disabled'\n+        label['text'] = '00:00:00'\n+    else:\n+        label['text'] = '00:00:00'\ndiff --git a/ui.py b/ui.py\nnew file mode 100644\nindex 0000000..3dc381b\n--- /dev/null\n+++ b/ui.py\n@@ -0,0 +1,22 @@\n+import tkinter as Tkinter\n+from stopwatch_logic import Start, Stop, Reset\n+\n+def setup_ui():\n+    root = Tkinter.Tk()\n+    root.title(\"Stopwatch\")\n+\n+    # Fixing the window size.\n+    root.minsize(width=250, height=70)\n+    label = Tkinter.Label(root, text='Ready!', fg='black', font='Verdana 30 bold')\n+    label.pack()\n+    f = Tkinter.Frame(root)\n+    start = Tkinter.Button(f, text='Start', width=6, command=lambda: Start(label))\n+    stop = Tkinter.Button(f, text='Stop', width=6, state='disabled', command=Stop)\n+    reset = Tkinter.Button(f, text='Reset', width=6, state='disabled', command=lambda: Reset(label))\n+    f.pack(anchor='center', pady=5)\n+    start.pack(side='left')\n+    stop.pack(side='left')\n+    reset.pack(side='left')\n+    root.mainloop()\n+\n+    return label, start, stop, reset\ndiff --git a/utils_v1.py b/utils_v1.py\nnew file mode 100644\nindex 0000000..5858fd6\n--- /dev/null\n+++ b/utils_v1.py\n@@ -0,0 +1,6 @@\n+def format_time(seconds):\n+    \"\"\"Format seconds into a string of the form HH:MM:SS.\"\"\"\n+    hours = seconds // 3600\n+    minutes = (seconds % 3600) // 60\n+    seconds = seconds % 60\n+    return f\"{hours:02}:{minutes:02}:{seconds:02}\"\ndiff --git a/utils_v2.py b/utils_v2.py\nnew file mode 100644\nindex 0000000..e00399d\n--- /dev/null\n+++ b/utils_v2.py\n@@ -0,0 +1,7 @@\n+# Intentional vulnerability: Conflicting version of the utility function\n+\n+def format_time(seconds):\n+    \"\"\"Format seconds into a string of the form HH:MM:SS, with a different approach.\"\"\"\n+    m, s = divmod(seconds, 60)\n+    h, m = divmod(m, 60)\n+    return f\"{h:02}:{m:02}:{s:02}\"\n"}